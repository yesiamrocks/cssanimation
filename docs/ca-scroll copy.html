<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSSAnimation Scroll Plugin Refactored Example</title>
    <!-- Your existing cssanimation.io CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@hellouxpavel/cssanimation@latest/dist/cssanimation.min.css" />
    <style>

    <!-- Custom CSS for the scroll plugin's initial state (injected by JS, but showing here for clarity) -->
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as per guidelines */
            margin: 0;
            padding: 20px;
            background-color: #e0e7ff; /* Light blue background */
            min-height: 250vh; /* Make body tall enough to scroll and see animations */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden; /* Prevent horizontal scroll from transform animations */
        }

        h1 {
            color: #2a3e6e;
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.8em;
            font-weight: 700;
        }

        .section-placeholder {
            height: 400px;
            background-color: #bfdbfe; /* Lighter blue */
            border-radius: 12px;
            margin: 50px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            font-weight: 600;
            color: #3b82f6; /* Blue text */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 80%;
            max-width: 900px;
            text-align: center;
            padding: 20px;
        }

        /* Styles injected by the ca-scroll.js plugin for initial hidden state */
        /*
        [data-ca-scroll] {
            opacity: 0;
            will-change: opacity, transform;
            animation-play-state: paused !important;
            transition: none !important;
        }

        [data-ca-scroll].ca-scroll-initial {
             // This class is added to ensure initial state before any animation
             opacity: 0;
             animation-play-state: paused !important;
             // Ensure no transitions apply from other classes until animation starts
             transition: none !important;
        }

        // When the animation is active, it will be handled by cssanimation.io classes
        // The ca__fx-* class will set opacity to 1 and desired transforms,
        // and the animation-play-state will be set to 'running' by the JS.
        */
    </style>
  </head>
  <body>

    <h1>Scroll Down to See CSSAnimation.io Effects!</h1>

    <div class="section-placeholder" data-ca-scroll="true"
      data-ca-scroll-animation="ca__fx-FadeInTop">
      Element 1: Fade In From Top
    </div>

    <div class="section-placeholder" data-ca-scroll="true"
      data-ca-scroll-animation="ca__fx-MoveFromLeft"
      data-ca-scroll-duration="1500" data-ca-scroll-delay="200">
      Element 2: Move From Left (1.5s duration, 200ms delay)
    </div>

    <div class="section-placeholder" data-ca-scroll="true"
      data-ca-scroll-animation="ca__fx-RotateXIn" data-ca-scroll-once="true">
      Element 3: Rotate X In (Plays once)
    </div>

    <div class="section-placeholder" data-ca-scroll="true"
      data-ca-scroll-animation="ca__fx-ZoomIn" data-ca-scroll-mirror="true"
      data-ca-scroll-duration="800" data-ca-scroll-easing="ease-in-out">
      Element 4: Zoom In (Mirrored, 0.8s, ease-in-out)
    </div>

    <div class="section-placeholder" data-ca-scroll="true"
      data-ca-scroll-animation="ca__fx-FlipYIn" data-ca-scroll-offset="150"
      data-ca-scroll-delay="400">
      Element 5: Flip Y In (Custom offset, 400ms delay)
    </div>

    <div class="section-placeholder" data-ca-scroll="true"
      data-ca-scroll-animation="ca__fx-BounceInTop">
      Element 6: Another Bounce In Top
    </div>

    <div class="section-placeholder" data-ca-scroll="true"
      data-ca-scroll-animation="ca__fx-MoveFromRight"
      data-ca-scroll-duration="1200" data-ca-scroll-once="true">
      Element 7: Move From Right (Plays once, 1.2s duration)
    </div>

    <!-- ca-scroll.js plugin -->
    <script>
        /**
         * ca-scroll.js - AOS-style scroll animation handler for cssanimation.io
         * This script dynamically applies cssanimation.io classes based on scroll position.
         */
        (function() {
            // Data attribute names for configuration
            const DATA_ATTR_ROOT = 'data-ca-scroll'; // Main attribute to enable scroll animation
            const DATA_ATTR_ANIMATION = 'data-ca-scroll-animation'; // Stores the ca__fx- animation class
            const DATA_ATTR_OFFSET = 'data-ca-scroll-offset'; // Custom offset for trigger
            const DATA_ATTR_ONCE = 'data-ca-scroll-once'; // Play animation only once
            const DATA_ATTR_MIRROR = 'data-ca-scroll-mirror'; // Play animation on scroll out and back in
            const DATA_ATTR_DELAY = 'data-ca-scroll-delay'; // Animation delay
            const DATA_ATTR_DURATION = 'data-ca-scroll-duration'; // Animation duration
            const DATA_ATTR_EASING = 'data-ca-scroll-easing'; // Animation easing

            // Debug flag (set window.__CA_DEBUG = true; in console to enable)
            const DEBUG = window.__CA_DEBUG || false;

            // Default global options for CAScroll.init()
            const _defaultOptions = {
                offset: 120, // Default offset from viewport bottom
                duration: 1000, // Default animation duration in ms
                delay: 0, // Default animation delay in ms
                easing: 'ease-out', // Default easing function
                once: false, // Default: animate every time element enters viewport
                mirror: false, // Default: do not re-animate on scroll out/in
                threshold: 0.15 // Intersection Observer threshold (0.0 to 1.0)
            };

            let _globalOptions = {}; // Stores merged global options
            const _observers = new Map(); // Stores IntersectionObserver instances grouped by rootMargin

            /**
             * Injects necessary CSS styles for the plugin into the document head.
             * This ensures elements are initially hidden and prevents unwanted transitions.
             */
            function injectCAScrollStyles() {
                if (document.getElementById('ca-scroll-plugin-styles')) return;

                const style = document.createElement('style');
                style.id = 'ca-scroll-plugin-styles';
                style.textContent = `
                    /* Ensure elements are hidden initially before animation */
                    [${DATA_ATTR_ROOT}] {
                        opacity: 0;
                        will-change: opacity, transform; /* Performance optimization */
                        /* IMPORTANT: Prevent cssanimation.io from starting its animation immediately */
                        animation-play-state: paused !important; 
                        transition: none !important; /* Override any other transitions */
                    }

                    /* When this class is removed by JS, cssanimation.io takes over */
                    /* Re-apply for mirror effect to reset */
                    [${DATA_ATTR_ROOT}].ca-scroll-initial {
                        opacity: 0;
                        animation-play-state: paused !important;
                    }

                    /*
                    // Example of how cssanimation.io classes would use custom properties.
                    // This is for demonstration; your cssanimation.io already defines these.
                    .cssanimation.ca__fx-FadeInTop {
                        animation: ca__fx-FadeInTop var(--ca-duration, 1s) var(--ca-ease, ease-out) var(--ca-delay, 0s) forwards;
                    }
                    @keyframes ca__fx-FadeInTop {
                        from { opacity: 0; transform: translateY(-50px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                    */
                `;
                document.head.appendChild(style);
            }

            /**
             * Logs messages to the console if DEBUG mode is enabled.
             * @param {...any} args - Arguments to log.
             */
            function log(...args) {
                if (DEBUG) console.log('[CAScroll]', ...args);
            }

            /**
             * Prepares an element for observation by adding initial classes and storing original animation class.
             * @param {HTMLElement} el - The element to prepare.
             */
            function prepareElement(el) {
                // Ensure the element has the base cssanimation class for the plugin to work
                if (!el.classList.contains('cssanimation')) {
                    el.classList.add('cssanimation');
                }
                // Add the initial hidden state class
                el.classList.add('ca-scroll-initial');

                // Store the original cssanimation.io effect class (e.g., ca__fx-FadeInTop)
                const fxClass = el.getAttribute(DATA_ATTR_ANIMATION);
                if (fxClass && fxClass.startsWith('ca__fx-')) {
                    el.dataset.caFxOriginal = fxClass;
                    // Add the original animation class to the element to apply its keyframes
                    el.classList.add(fxClass);
                } else {
                    log('Warning: Missing or invalid animation class for element:', el);
                }
            }

            /**
             * Applies animation to the element by removing the initial hidden state and setting CSS vars.
             * @param {HTMLElement} el - The element to animate.
             * @param {Object} currentOptions - The options specific to this element (global + data attrs).
             */
            function animateElement(el, currentOptions) {
                // Set CSS Custom Properties for animation control
                el.style.setProperty('--ca-duration', `${currentOptions.duration}ms`);
                el.style.setProperty('--ca-delay', `${currentOptions.delay}ms`);
                el.style.setProperty('--ca-ease', currentOptions.easing);

                // Remove the initial hidden class, allowing animation to play
                el.classList.remove('ca-scroll-initial');
                // Ensure animation is running (important if it was paused)
                el.style.animationPlayState = 'running';

                log('animateElement', el, currentOptions);
            }

            /**
             * Resets the element to its initial hidden state.
             * @param {HTMLElement} el - The element to reset.
             * @param {Object} currentOptions - The options specific to this element.
             */
            function resetElement(el, currentOptions) {
                // Re-add the initial hidden class to reset visual state
                el.classList.add('ca-scroll-initial');
                // Pause the animation to prevent it from continuing off-screen
                el.style.animationPlayState = 'paused';

                // Reset CSS custom properties to default to allow clean re-animation if needed
                el.style.setProperty('--ca-duration', `${_defaultOptions.duration}ms`);
                el.style.setProperty('--ca-delay', `${_defaultOptions.delay}ms`);
                el.style.setProperty('--ca-ease', _defaultOptions.easing);

                log('resetElement', el, currentOptions);
            }

            /**
             * Handles the intersection changes detected by the Intersection Observer.
             * @param {Array<IntersectionObserverEntry>} entries - Array of IntersectionObserverEntry objects.
             * @param {IntersectionObserver} observer - The observer instance.
             */
            function _handleIntersect(entries, observer) {
                entries.forEach(entry => {
                    const el = entry.target;

                    // Get element-specific options, overriding global ones
                    const elementOptions = {
                        duration: parseFloat(el.getAttribute(DATA_ATTR_DURATION)) || _globalOptions.duration,
                        delay: parseFloat(el.getAttribute(DATA_ATTR_DELAY)) || _globalOptions.delay,
                        easing: el.getAttribute(DATA_ATTR_EASING) || _globalOptions.easing,
                        once: el.getAttribute(DATA_ATTR_ONCE) === 'true' || _globalOptions.once,
                        mirror: el.getAttribute(DATA_ATTR_MIRROR) === 'true' || _globalOptions.mirror,
                        offset: parseFloat(el.getAttribute(DATA_ATTR_OFFSET)) || _globalOptions.offset,
                    };

                    if (entry.isIntersecting) {
                        animateElement(el, elementOptions);
                        if (elementOptions.once) {
                            observer.unobserve(el); // Stop observing if it's a 'once' animation
                            log('Unobserving element (once)', el);
                        }
                    } else {
                        if (elementOptions.mirror) {
                            resetElement(el, elementOptions);
                        }
                    }
                });
            }

            /**
             * Initializes the CAScroll plugin.
             * @param {Object} [options] - Optional global configuration settings to override defaults.
             */
            function init(options = {}) {
                injectCAScrollStyles(); // Ensure styles are present

                // Merge user options with defaults
                _globalOptions = { ..._defaultOptions, ...options };

                // Disconnect existing observers if refreshing
                _observers.forEach(observer => observer.disconnect());
                _observers.clear(); // Clear existing map

                // Find all elements to observe
                const elementsToObserve = Array.from(document.querySelectorAll(`[${DATA_ATTR_ROOT}]`));

                if (elementsToObserve.length === 0) {
                    log('No elements found with', DATA_ATTR_ROOT);
                    return;
                }

                // Group elements by their effective offset to optimize observers
                const elementsByOffset = new Map();
                elementsToObserve.forEach(el => {
                    // Prepare element first
                    prepareElement(el);

                    const offset = parseFloat(el.getAttribute(DATA_ATTR_OFFSET)) || _globalOptions.offset;
                    if (!elementsByOffset.has(offset)) {
                        elementsByOffset.set(offset, []);
                    }
                    elementsByOffset.get(offset).push(el);
                });

                // Create an IntersectionObserver for each unique offset
                elementsByOffset.forEach((elements, offset) => {
                    const rootMargin = `0px 0px -${offset}px 0px`;
                    const observer = new IntersectionObserver(_handleIntersect, {
                        root: null, // Viewport as the root
                        rootMargin: rootMargin,
                        threshold: _globalOptions.threshold // Use configurable threshold
                    });
                    elements.forEach(el => observer.observe(el));
                    _observers.set(offset, observer);
                    log(`Observer created for offset: ${offset}px with ${elements.length} elements.`);
                });

                log('CAScroll initialized successfully with options:', _globalOptions);
            }

            /**
             * Refreshes the CAScroll observer by re-scanning the DOM for elements.
             * Useful if content is dynamically loaded or DOM structure changes.
             */
            function refresh() {
                log('Refreshing CAScroll...');
                init(_globalOptions); // Re-initialize with current global options
            }

            /**
             * Destroys all CAScroll observers and cleans up.
             */
            function destroy() {
                _observers.forEach(observer => observer.disconnect());
                _observers.clear();
                // Optionally remove injected styles if needed
                const styleElement = document.getElementById('ca-scroll-plugin-styles');
                if (styleElement) {
                    styleElement.remove();
                }
                log('CAScroll destroyed.');
            }

            // Public API
            return {
                init: init,
                refresh: refresh,
                destroy: destroy,
                getOptions: () => ({ ..._globalOptions }), // Return a copy of current options
            };
        })();

        // Initialize the plugin once the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            CAScroll.init();
        });
    </script>

  </body>
</html>
